<!-- 81be7940-d8f0-4c1b-bbf1-6513c0d2112f ab5912b3-db79-4399-8a05-b35598c0ab63 -->
# 重构实体死亡处理系统

## 问题分析

当前设计存在以下问题：

1. **死亡事件重复发布**：ProjectileSystem 在死亡时就发布销毁事件，导致尸体立即消失
2. **死亡检测分散**：FlowFieldSystem、CombatSystem、ProjectileSystem 都有重复的死亡检测逻辑
3. **职责不清**：移动系统不应负责添加死亡组件
4. **缺少死亡动画支持**：没有专门的事件通知表现层播放死亡动画

## 解决方案

### 1. 创建 HealthSystem（新文件）

**路径**：`Packages/ZLockstep/Runtime/Simulation/ECS/Systems/HealthSystem.cs`

统一处理所有生命值检测和死亡标记：

- 遍历所有有 `HealthComponent` 的实体
- 检测 `CurrentHealth <= 0` 且没有 `DeathComponent` 的实体
- 添加 `DeathComponent`（2秒后移除尸体）
- 发布 `EntityDiedEvent` 通知表现层播放死亡动画

### 2. 创建 EntityDiedEvent（新文件）

**路径**：`Packages/ZLockstep/Runtime/Simulation/Events/EntityDiedEvent.cs`

```csharp
public struct EntityDiedEvent : IEvent
{
    public int EntityId;
    public int CampId;
}
```

### 3. 修改 ProjectileSystem

**移除**：

- `OnEntityDeath()` 方法（第141-154行）
- 第126-130行的死亡处理和事件发布

**改为**：造成伤害后直接写回 HealthComponent，由 HealthSystem 统一处理

### 4. 修改 CombatSystem

**移除所有死亡检测逻辑**：

- 第44-55行：攻击者死亡检测
- 第176-180行：搜索目标时的死亡检测
- 第218-222行：目标验证时的死亡检测

**改为**：只检查 `DeathComponent` 是否存在，不再检查生命值

### 5. 修改 FlowFieldSystem

**移除**：第405-416行的死亡检测和 DeathComponent 添加逻辑

**保留**：只检查 `DeathComponent` 并清除移动目标

### 6. 修改 PresentationSystem

**添加**：处理 `EntityDiedEvent` 的方法

- 在 `Update()` 中调用 `ProcessEntityDiedEvents()`
- 触发 Animator 的死亡动画
- 不销毁 GameObject，等待 `UnitDestroyedEvent`

### 7. 修改 SettlementSystem

确保只依赖 `DeathComponent` 检测，不重复检查生命值

### 8. 注册 HealthSystem

在 `BattleGame.RegisterSystems()` 中，在 ProjectileSystem 之后、DeathRemovalSystem 之前注册

## 执行顺序

系统执行顺序：

1. CombatSystem（造成伤害）
2. ProjectileSystem（造成伤害）
3. **HealthSystem**（检测死亡，发布事件）
4. DeathRemovalSystem（移除尸体）
5. PresentationSystem（处理事件，播放动画）

## 预期效果

- 死亡逻辑集中在 HealthSystem，易于维护
- 死亡时播放动画，2秒后销毁视图
- 各系统职责清晰，不再重复检测生命值

### To-dos

- [ ] 创建 HealthSystem.cs 统一处理生命值检测和死亡标记
- [ ] 创建 EntityDiedEvent.cs 死亡动画事件
- [ ] 重构 ProjectileSystem 移除死亡处理逻辑
- [ ] 重构 CombatSystem 移除死亡检测逻辑
- [ ] 重构 FlowFieldSystem 移除死亡组件添加逻辑
- [ ] 修改 PresentationSystem 处理死亡动画事件
- [ ] 在 BattleGame 中注册 HealthSystem