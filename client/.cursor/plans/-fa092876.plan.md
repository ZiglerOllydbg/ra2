<!-- fa092876-76df-40bb-ada6-14cd14e08075 380487d4-472c-46b4-afc7-5cfc95f5e061 -->
# 多源流场(B)与散点分配实现计划

#### 目标

- 多个散点作为 Dijkstra 多源起点，生成一个共享流场；所有单位复用同一 fieldId。
- 远距离跟随共享流场，近端按各自散点做收敛（已具备）。
- 提供实用的散点生成（蜂窝阵列）与去重/可走/净空校验与分配（贪心匹配）。

#### 设计要点

- 计算层：新增多源计算，不影响单源路径；按去重排序后的格子集合作为缓存 key。
- 管理层：新增 `RequestFlowFieldMulti` 与缓存（独立于单源缓存），记录目标集合与包围盒，脏区更新基于包围盒判断。
- 系统层：新增 `SetScatterTargets`，生成散点→投影→分配→请求多源 field→为每个单位设置个人目标与共享 field。

#### 涉及文件与改动

- `Packages/ZLockstep/Runtime/Flow/FlowFieldCore.cs`
  - 新增：`FlowFieldCalculator.CalculateMulti(FlowField field, IFlowFieldMap map, List<(int x,int y)> targets)`
    - 初始化：将所有 `targets`（去重）以 cost=0 入队，Dijkstra 其余逻辑复用。
  - 扩展 `FlowField`：
    - `public bool isMulti;`
    - `public int[] targetXs, targetYs;`
    - `public int minTargetX, minTargetY, maxTargetX, maxTargetY;`（包围盒）

- `Packages/ZLockstep/Runtime/Flow/FlowFieldManager.cs`
  - 新增缓存：`Dictionary<string, FlowField> multiFieldCache;`
  - 新增 API：`public int RequestFlowFieldMulti(List<(int x,int y)> targetCells)` 与 `public int RequestFlowFieldMultiWorld(List<zVector2> targets)`
    - 处理：world→grid→去重→排序→key=`"x_y|..."`→缓存命中则 `ref++`，否则创建 `FlowField{ isMulti=true, targets..., bbox... }` 并 `CalculateMulti`。
  - `UpdateDirtyFields/ForceUpdateFlowField`：依据 `field.isMulti` 调用对应计算。
  - `MarkRegionDirty`：单源：沿用当前目标点判断；多源：若脏区与 `field` 包围盒相交则标脏入队（用 `dirtySet` 去重）。
  - `Clear/CleanupUnusedFields`：同时清理 `multiFieldCache`。

- `Packages/ZLockstep/Runtime/Flow/FlowFieldSystem.cs`
  - 新增 API：
    - `public void SetScatterTargets(List<Entity> entities, zVector2 groupCenter)`
      - 计算单位半径/建议最小距离 `d = 2*radius*1.2`
      - 生成蜂窝阵列候选：`GenerateHexLattice(groupCenter, d, rings)`
      - `ProjectToWalkable` → `HasClearance` → 去重到 N 个散点（N=entities.Count）
      - `GreedyAssign(entities currentPos, scatterPoints)` 返回映射
      - 调 `flowFieldManager.RequestFlowFieldMulti(targetCells)` 获取共享 `fieldId`
      - 对每个单位：`navigator.CurrentFlowFieldId=fieldId`，`MoveTarget.TargetPosition=个人散点`
  - 新增私有辅助：`GenerateHexLattice`、`ProjectToWalkable`（小范围 BFS/邻域扫描）、`HasClearance`（检查邻域可走）、`GreedyAssign`。

- `Assets/Scripts/Examples/StandaloneBattleDemo.cs`
  - 在 `MoveSelectedUnits` 中，若选中数量>1：调用 `NavSystem.SetScatterTargets(_selectedUnits, targetPosition)`；否则保留单目标。

#### 关键伪代码

- 多源计算入口：
```csharp
public static void CalculateMulti(FlowField field, IFlowFieldMap map, List<(int x,int y)> targets) {
    // init costs=Infinity
    // enqueue all unique targets with cost=0
    // Dijkstra 同现有实现
    // AddWallPenalty + GenerateDirectionField 复用
}
```

- 多源缓存 key：
```csharp
// targets 已按 (y,x) 排序、去重
string key = string.Join("|", targets.Select(t => $"{t.x}_{t.y}"));
```

- 散点生成（蜂窝阵列）：
```csharp
IEnumerable<zVector2> GenerateHex(zVector2 center, zfloat d, int rings)
// 环 0: center; 环 k: 6k 点，边向量基于 60° 方向
```

- 投影与净空：
```csharp
zVector2 ProjectToWalkable(zVector2 p) // 先取其格子，若不可走，沿 8 邻域按环扩展找最近可走格
bool HasClearance(int gx,int gy, int minClearCells) // 检 8 邻或基于地图格大小≈半径
```

- 分配：
```csharp
Dictionary<Entity,zVector2> GreedyAssign(List<Entity> es, List<zVector2> pts) {
    // 以实体当前位置到散点距离排序，逐个挑最近未占用散点
}
```


#### 数值/参数默认值

- 最小间距 d = `2*maxRadius*1.2`；rings 自适应直到收集到 N 个散点。
- `ArrivalRadius = max(ArrivalRadius, radius*1.2)`；`SlowDownRadius` 可适度增大（例如 3~5m）。

#### 开放问题（不阻塞实现，若无回复按默认处理）

1. 是否需要匈牙利最优匹配替代贪心？

   - a) 先用贪心（默认）
   - b) 上匈牙利（更平滑，但 O(n^3)）

2. `ProjectToWalkable` 的最大搜索半径？

   - a) 8~12 个格子（默认）
   - b) 更大（可配）

### To-dos

- [ ] FlowFieldCalculator 增加 CalculateMulti 多源计算
- [ ] FlowField 扩展 isMulti/targets/bbox 字段
- [ ] FlowFieldManager 新增 RequestFlowFieldMulti 与多源缓存
- [ ] MarkRegionDirty/UpdateDirtyFields 支持多源包围盒判定
- [ ] NavigationSystem 新增 SetScatterTargets 与辅助算法
- [ ] StandaloneBattleDemo 调用 SetScatterTargets 分支