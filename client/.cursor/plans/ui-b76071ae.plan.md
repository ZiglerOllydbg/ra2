<!-- b76071ae-fbb8-4d29-8533-909dfd8491ef a2f7531c-65b8-4649-b34d-e6bc71f56c82 -->
# UI面板状态机简化重构方案

## 核心改进

### 1. 用状态枚举替代多个bool标志

**当前问题**：

- `IsOpen`、`IsLoading`、`IsVisiable` 三个bool可组合出8种状态
- 状态转换逻辑分散在多个方法中
- 异步加载时状态管理容易出错

**改进方案**：使用单一的状态枚举 `PanelState`

```csharp
public enum PanelState
{
    Uninitialized,  // 未初始化（刚创建）
    Closed,         // 已关闭（有资源或无资源）
    Loading,        // 正在加载资源
    Loaded,         // 资源已加载，但未显示
    Opening,        // 正在打开（播放动画）
    Opened,         // 已打开并显示
    Closing,        // 正在关闭（播放动画）
}
```

### 2. 状态转换集中管理

在BasePanel中添加状态转换方法：

```csharp
private PanelState state = PanelState.Uninitialized;

/// <summary>
/// 获取当前状态
/// </summary>
public PanelState State => state;

/// <summary>
/// 状态转换（集中管理，便于调试）
/// </summary>
private void TransitionTo(PanelState newState)
{
    // 状态转换合法性检查
    if (!IsValidTransition(state, newState))
    {
        this.LogError($"Invalid state transition: {state} -> {newState}");
        return;
    }
    
    var oldState = state;
    state = newState;
    
    this.Log($"State: {oldState} -> {newState}");
    
    // 可选：发布状态变化事件
    OnStateChanged(oldState, newState);
}

/// <summary>
/// 检查状态转换是否合法
/// </summary>
private bool IsValidTransition(PanelState from, PanelState to)
{
    // 定义合法的状态转换
    switch (from)
    {
        case PanelState.Uninitialized:
            return to == PanelState.Closed;
            
        case PanelState.Closed:
            return to == PanelState.Loading || to == PanelState.Loaded;
            
        case PanelState.Loading:
            return to == PanelState.Loaded || to == PanelState.Closed;
            
        case PanelState.Loaded:
            return to == PanelState.Opening || to == PanelState.Closed;
            
        case PanelState.Opening:
            return to == PanelState.Opened || to == PanelState.Closing;
            
        case PanelState.Opened:
            return to == PanelState.Closing;
            
        case PanelState.Closing:
            return to == PanelState.Closed;
            
        default:
            return false;
    }
}
```

### 3. 简化Open/Close逻辑

```csharp
public virtual void Open(PanelSkinID skinID = PanelSkinID.None)
{
    switch (state)
    {
        case PanelState.Closed:
        case PanelState.Uninitialized:
            // 需要加载资源
            if (PanelObject == null || panelSkinID != skinID)
            {
                TransitionTo(PanelState.Loading);
                LoadUIPrefab(skinID);
            }
            else
            {
                // 资源已存在，直接打开
                TransitionTo(PanelState.Loaded);
                BeginOpen();
            }
            break;
            
        case PanelState.Loading:
            // 正在加载中，什么都不做（等加载完成后自动打开）
            this.LogWarning("Panel is loading, please wait...");
            break;
            
        case PanelState.Opened:
            // 已经打开，触发OnOpen回调
            OnOpen();
            break;
            
        default:
            this.LogWarning($"Cannot open panel in state: {state}");
            break;
    }
}

public virtual void Close()
{
    switch (state)
    {
        case PanelState.Opened:
            TransitionTo(PanelState.Closing);
            BeginClose();
            break;
            
        case PanelState.Loading:
            // 加载中被关闭，标记为需要关闭，等加载完成后自动关闭
            TransitionTo(PanelState.Closed);
            this.LogWarning("Close during loading, will close after loaded");
            break;
            
        case PanelState.Closed:
            // 已经关闭，不需要操作
            break;
            
        default:
            this.LogWarning($"Cannot close panel in state: {state}");
            break;
    }
}
```

### 4. 处理异步加载回调

```csharp
protected virtual void BorrowComplete(PanelID panelID, PanelSkinID skinID, GameObject go)
{
    if (go == null)
    {
        this.LogError("Load UI failed!");
        TransitionTo(PanelState.Closed);
        OnLoadComplete?.Invoke(false);
        return;
    }
    
    this.PanelObject = go;
    // 设置Parent、RectTransform等...
    
    TransitionTo(PanelState.Loaded);
    
    // 检查加载完成时的状态
    if (state == PanelState.Closed)
    {
        // 加载期间被关闭了，直接释放资源
        this.LogWarning("Panel was closed during loading");
        CloseByActionType();
    }
    else
    {
        // 正常打开
        BeginOpen();
    }
}

private void BeginOpen()
{
    TransitionTo(PanelState.Opening);
    
    SetUIReadyThenGetPanelComponent();
    
    // TODO: 播放打开动画
    // 动画完成后调用 OnOpenComplete()
    
    OnOpenComplete();
}

private void OnOpenComplete()
{
    TransitionTo(PanelState.Opened);
    
    this.UIDepth = this.UIDepth;
    CanvasRectTransAdapt();
    
    UpdateData();
    BecameVisible();
    
    OnLoadComplete?.Invoke(true);
}

private void BeginClose()
{
    BecameInvisible();
    
    // TODO: 播放关闭动画
    // 动画完成后调用 OnCloseComplete()
    
    OnCloseComplete();
}

private void OnCloseComplete()
{
    TransitionTo(PanelState.Closed);
    
    CloseByActionType();
    PanelManager.instance.ClosePanel(this);
}
```

### 5. 提供兼容属性（可选）

如果不想修改太多外部代码，可以提供兼容属性：

```csharp
/// <summary>
/// 兼容属性：是否打开
/// </summary>
public bool IsOpen => state == PanelState.Opened || 
                      state == PanelState.Opening || 
                      state == PanelState.Loading ||
                      state == PanelState.Loaded;

/// <summary>
/// 兼容属性：是否正在加载
/// </summary>
public bool IsLoading => state == PanelState.Loading;

/// <summary>
/// 兼容属性：是否可见
/// </summary>
public bool IsVisiable => state == PanelState.Opened;
```

## 改进效果

### 之前（复杂）：

```csharp
// 状态分散，难以理解
IsOpen = true;
IsLoading = true;
// ... 100行代码后 ...
IsLoading = false;
if (IsOpen) {
    IsVisiable = true;
}
```

### 之后（清晰）：

```csharp
TransitionTo(PanelState.Loading);
// ... 异步加载 ...
TransitionTo(PanelState.Loaded);
TransitionTo(PanelState.Opened);
```

## 主要修改文件

1. **BasePanel.cs** - 核心修改

   - 添加PanelState枚举
   - 添加TransitionTo()状态转换方法
   - 重构Open()、Close()、BorrowComplete()等方法
   - 添加状态转换合法性检查

2. **PanelManager.cs** - 轻微修改

   - OpenPanel()、ClosePanel()根据新状态调整

3. **具体Panel子类** - 无需修改

   - 兼容属性保证外部代码无需改动

## 优势总结

1. ✅ **状态清晰**：一目了然当前处于什么状态
2. ✅ **转换安全**：非法状态转换会被拦截
3. ✅ **易于调试**：集中的日志输出
4. ✅ **异步友好**：明确处理加载中被关闭的情况
5. ✅ **易扩展**：新增状态（如Opening动画）很容易