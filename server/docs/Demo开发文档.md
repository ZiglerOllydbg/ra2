# Demo服务器开发文档


# 思路

## 启动
1. 启动匹配线程
1. 启动房间线程池
1. 启动websocket网络


## 网络
- 使用netty的websocket
- 协议使用json，每个协议都包含type和data字段
- WebSocketSessionManager
    - 使用ConcurrentHashMap管理websocket的channel
    - 线程安全的发送消息函数：使用channel.eventLoop().execute
- websocket的match消息，直接添加匹配线程的消息队列中
- websocket保存房间线程和房间id信息，用于转发其他消息到房间线程。
- 断开连接，如果有房间信息，添加断线任务到房间线程的消息队列中。否则添加断线任务到匹配线程的消息队列中。


## 线程
- 匹配线程MatchThread：仅有一个线程，处理所有匹配请求。
- 房间线程池RoomThread：一个线程多个房间，顺序分配房间到房间线程。
- 网络与线程之间使用消息队列，消息队列使用LinkedBlockingQueue。消息队列结构包含channelId（用于其他线程给客户端发送消息使用），消息类型，消息数据等。
- 线程之间通过任务队列交互：LinkedBlockingQueue<Runnable>
- 线程心跳逻辑（每秒20帧，也是帧同步频率）：
    - 先处理消息队列
    - 再处理任务队列
    - 线程心跳逻辑



## 匹配、创建房间、游戏开始、帧同步协议流程
- 匹配协议：{"type":"match","data":{"name":"xxxx"}}，添加到匹配线程的消息队列中。
- 匹配线程心跳逻辑：处理匹配队列，2个玩家一组，创建房间。
- 将房间分配到房间线程：可以添加房间线程任务队列中。
- 房间线程处理任务，同步绑定websocket的房间线程和房间id。通知客户端准备进入场景，并包含所有玩家信息。{"type":"matchSuccess","data":[{"id":1,"name":"xxxx"},{"id":2,"name":"xxxx"}]}
- 等待所有客户端准备完成ready. {"type":"ready"}
- 全部客户端准备完成，开始游戏。广播：{"type":"gameStart"}
- 客户端收到gameStart开始游戏
- 客户端每帧收集输入数据，通过{"type": "frameInput", "data": {"frame": N+2, inputs: [{"id":1,"input":[1,2,3]},{"id":2,"input":[4,5,6]}]}} 协议,发送给服务器。+2帧，对抗延迟。
- 服务器网络接收frameInput，转发房间线程的消息队列中。
- 房间线程每帧处理消息队列
    1. 将输入保存对应帧数据中。FrameData[frame][playerId] = input
    1. 判断当前帧是否收到所有玩家的输入数据，没有的补充空输入。
    1. 帧同步广播：{"type":"frameSync","data":{"frame":N, "frameData":[{"id":1,"input":[1,2,3]},{"id":2,"input":[4,5,6]}]}}
- 客户端收到frameSync，根据这个协议，进行锁步和追帧处理。


------------------------------

好的，这看起来是一份关于实时对战游戏后端服务器的详细开发文档。我将根据您提供的思路进行整理和总结。

### **核心设计思路**

该服务器采用的是一个经典的实时对战游戏后端架构，核心在于将不同职责的逻辑分离到独立的线程中，通过消息队列进行异步通信，以实现高效、无阻塞的处理。整体采用“帧同步”方案，确保多端游戏逻辑的一致性。

### **一、启动流程**

服务器的启动过程清晰明了，按照顺序初始化三大核心模块：
1.  **启动匹配线程**：专门用于处理玩家匹配请求的单一线程。
2.  **启动房间线程池**：用于管理所有游戏房间的逻辑，一个线程可以承载多个房间。
3.  **启动WebSocket网络**：初始化Netty服务器，开始监听客户端的WebSocket连接。

### **二、网络层设计**

网络层是服务器与客户端沟通的桥梁，其设计要点如下：
*   **网络框架**：采用高性能的Java网络框架Netty，并使用其WebSocket支持。
*   **通信协议**：协议格式为JSON，结构清晰，包含`type`（消息类型）和`data`（消息内容）两个关键字段。
*   **会话管理 (WebSocketSessionManager)**：
    *   使用`ConcurrentHashMap`来安全地管理所有客户端的WebSocket连接（Channel），确保高并发下的线程安全。
    *   封装了线程安全的消息发送函数，通过将发送操作提交到Channel自身的`eventLoop`来执行，避免了多线程直接操作Channel可能引发的冲突。
*   **消息路由**：
    *   **匹配消息**：当收到类型为`match`的消息时，直接将其放入匹配线程的消息队列中。
    *   **房间消息**：为了方便后续通信，WebSocket会话中会保存客户端所在的`房间线程`和`房间ID`。收到游戏中的消息（如帧输入）后，可根据这些信息直接转发到对应房间线程的消息队列中。
    *   **断线处理**：当一个客户端断开连接时，服务器会检查其状态。如果玩家在房间内，则向该房间所在的线程队列添加一个“断线任务”；如果玩家正在匹配或未在任何房间内，则向匹配线程队列添加“断线任务”。

### **三、线程模型**

服务器采用了多线程模型来分离不同业务，提高处理能力。
*   **匹配线程 (MatchThread)**：
    *   采用**单线程**模型，所有匹配请求都在此排队处理，避免了处理匹配逻辑时需要加锁的复杂性。
*   **房间线程池 (RoomThread)**：
    *   一个线程可以管理多个游戏房间。
    *   当新房间创建时，会按顺序（或根据负载）分配给一个房间线程。该房间内的所有后续逻辑都在这个线程中执行。
*   **线程间通信**：
    *   **消息队列**：网络线程与业务线程（匹配、房间）之间通过`LinkedBlockingQueue`实现的消息队列进行通信。消息体中包含`channelId`（用于业务线程向客户端回发消息）、消息类型和具体数据。
    *   **任务队列**：线程之间也通过一个`LinkedBlockingQueue<Runnable>`任务队列进行交互。一个线程可以将一个任务（Runnable）提交到另一个线程的队列中，由目标线程在自己的循环中执行。
*   **线程心跳 (Game Loop)**：
    *   所有业务线程（匹配、房间）都有一个固定的心跳逻辑，文档中设定为**每秒20帧**，这个频率也决定了帧同步的频率。
    *   每一帧（Tick）的执行顺序是固定的：
        1.  优先处理来自其他线程的消息队列。
        2.  接着处理来自其他线程的任务队列。
        3.  最后执行该线程自身的核心逻辑（如匹配逻辑、房间内的帧推进等）。

### **四、核心协议与流程**

这部分详细描述了从匹配到游戏核心同步的完整流程。

1.  **匹配请求**：
    *   客户端发送 `{"type":"match","data":{"name":"xxxx"}}` 协议。
    *   服务器网络层收到后，将此消息放入匹配线程的消息队列。

2.  **匹配成功与房间创建**：
    *   匹配线程在其心跳逻辑中，不断从队列里取出玩家进行匹配。
    *   当凑够一组玩家（例如2人）时，就创建一个房间，并将“初始化房间”这个任务添加到房间线程池中某个线程的任务队列里。

3.  **进入房间**：
    *   房间线程执行“初始化房间”任务，将玩家信息、WebSocket会话与房间进行绑定。
    *   随后，该线程向房间内的所有客户端广播`{"type":"matchSuccess","data":[...玩家信息...]}`协议，通知它们匹配成功，准备加载场景。

4.  **准备就绪**：
    *   客户端加载完成后，向服务器发送`{"type":"ready"}`协议。
    *   房间线程等待所有客户端都发送了`ready`消息。

5.  **游戏开始**：
    *   当所有玩家准备就绪后，房间线程广播`{"type":"gameStart"}`协议。
    *   客户端收到此协议后，正式开始游戏逻辑。

6.  **帧同步**：
    *   **客户端**：在每一帧，客户端会收集玩家的输入操作（如移动、放技能等），并将其打包成`{"type": "frameInput", "data": {"frame": N+2, "inputs": [...]}}`协议发送给服务器。这里的`N+2`是**提前上报**（帧提前），用于对抗网络延迟。`N`是客户端当前的帧。
    *   **服务器（网络层）**：接收到`frameInput`消息后，根据会话中保存的房间信息，将其转发到对应的房间线程消息队列。
    *   **服务器（房间线程）**：在其每秒20次的心跳中：
        1.  从消息队列中取出`frameInput`数据，并将其存储在对应帧的数据结构中，如 `FrameData[frame][playerId] = input`。
        2.  推进游戏逻辑帧（例如，处理第N帧）。检查是否已收到所有玩家在第N帧的输入。如果某个玩家的输入没有及时到达，则用空操作或上一次操作作为“补偿输入”。
        3.  将第N帧的所有（或已补偿的）玩家输入数据打包，向房间内所有客户端广播`{"type":"frameSync","data":{"frame":N, "frameData":[...]}}`协议。
    *   **客户端**：收到`frameSync`协议后，就获得了该帧所有玩家的确定性输入。客户端根据这些输入来驱动游戏逻辑的演算。通过这个机制，可以实现**锁步同步**（等待服务器帧数据）和**追帧**（落后时快速演算）。

